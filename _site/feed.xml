<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-04-29T21:19:35+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">hLunaaa</title><subtitle>8086 and C++23</subtitle><entry><title type="html">Examining Malware Thread Creation Techniques</title><link href="http://localhost:4000/2025/04/29/Examining-Malware-Thread-Creation-Techniques.html" rel="alternate" type="text/html" title="Examining Malware Thread Creation Techniques" /><published>2025-04-29T12:13:25+02:00</published><updated>2025-04-29T12:13:25+02:00</updated><id>http://localhost:4000/2025/04/29/Examining-Malware-Thread-Creation-Techniques</id><content type="html" xml:base="http://localhost:4000/2025/04/29/Examining-Malware-Thread-Creation-Techniques.html"><![CDATA[<p>Most malware want to quickly implant and exit the first stage of the payload execution. They do this by writing the second stage payload bytes to some executable memory and passing control there, either by creating a new thread or by redirecting an existing legitimate thread. In this post we examine the primarily four ways that most malware accomplish this.</p>

<p><code class="language-plaintext highlighter-rouge">CreateThread</code> and <code class="language-plaintext highlighter-rouge">CreateRemoteThread</code></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Most malware want to quickly implant and exit the first stage of the payload execution. They do this by writing the second stage payload bytes to some executable memory and passing control there, either by creating a new thread or by redirecting an existing legitimate thread. In this post we examine the primarily four ways that most malware accomplish this.]]></summary></entry><entry><title type="html">Bypassing CR3 Abuse with Physical R/W</title><link href="http://localhost:4000/2025/04/25/Bypassing-CR3-Abuse-with-Physical-RW-copy.html" rel="alternate" type="text/html" title="Bypassing CR3 Abuse with Physical R/W" /><published>2025-04-25T09:12:29+02:00</published><updated>2025-04-25T09:12:29+02:00</updated><id>http://localhost:4000/2025/04/25/Bypassing-CR3-Abuse-with-Physical-RW%20copy</id><content type="html" xml:base="http://localhost:4000/2025/04/25/Bypassing-CR3-Abuse-with-Physical-RW-copy.html"><![CDATA[<p>Some kernel mode anti-cheat solutions have now begun to obscure <code class="language-plaintext highlighter-rouge">KPROCESS.DirectoryTableBase</code> by effectively moving the address space via page table manipulation on startup. This prevents attaching to the real process space and makes it slightly more difficult for cheats and malware to to read/write the protected memory.</p>

<p>The problem? User processes were realistically already not able to interact with the protected memory, and kernel drivers and hypervisors have access to the underlying physical memory. Currently <code class="language-plaintext highlighter-rouge">EAC</code> and <code class="language-plaintext highlighter-rouge">VKG</code> implement some form of <code class="language-plaintext highlighter-rouge">CR3</code> abuse, but using monkey bruteforceâ„¢ we can walk all physical ranges and parse the <code class="language-plaintext highlighter-rouge">PML4</code>.</p>

<p>In theory, this can also be achieved from user mode as page tables are mapped to virtual memory with some assistance. We can even force a <code class="language-plaintext highlighter-rouge">TLB</code> flush using <code class="language-plaintext highlighter-rouge">SwitchToThread()</code>. The method relies on finding the self-referencing <code class="language-plaintext highlighter-rouge">PML4</code> entry, so the caller must have some level of access to the underlying physical memory, or leak non-exported names like <code class="language-plaintext highlighter-rouge">MmPteBase</code>, <code class="language-plaintext highlighter-rouge">MmPdeBase</code> and <code class="language-plaintext highlighter-rouge">MmPfnDatabase</code> which are used internally. More closely studying <code class="language-plaintext highlighter-rouge">MmGetVirtualForPhysical()</code> is recommended.</p>

<p>We first cache the physical memory ranges. Here we can either call <code class="language-plaintext highlighter-rouge">MmGetPhysicalMemoryRanges()</code> or implement the same behavior ourselves. The <a href="https://doxygen.reactos.org/d1/d6d/dynamic_8c.html#a4d2191536acfdbcab710579f81193527">ReactOS</a> source can help provide context, but obviously look at the disassembly of <code class="language-plaintext highlighter-rouge">MiReferencePageRuns()</code> as well.</p>

<p>When walking the pages, we assume the page is the correct <code class="language-plaintext highlighter-rouge">PML4</code> and attempt a translation using a known user address like <code class="language-plaintext highlighter-rouge">EPROCESS.SectionBaseAddress</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define _pfn_to_page(pfn) (pfn &lt;&lt; _page_shift)
#define _page_to_pfn(pfn) (pfn &gt;&gt; _page_shift)
</span>
<span class="n">u64</span> <span class="nf">mm_find_process_cr3</span><span class="p">(</span><span class="n">EPROCESS</span><span class="o">*</span> <span class="n">proc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">physical_range</span> <span class="o">=</span> <span class="n">MmGetPhysicalMemoryRanges</span><span class="p">();</span> <span class="c1">// free with ExFreePool</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">physical_range</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// for every physical range</span>
  <span class="c1">// for every page</span>
  <span class="c1">// for every page table entry -- self-ref can have any idx  </span>

  <span class="n">virt_addr_t</span> <span class="n">mz_base</span><span class="p">;</span>
  <span class="n">mz_base</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">SectionBaseAddress</span><span class="p">;</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="n">u64</span> <span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">physical_range</span><span class="o">-&gt;</span><span class="n">BaseAddress</span><span class="p">);</span>
    <span class="n">u64</span> <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">physical_range</span><span class="o">-&gt;</span><span class="n">BaseAddress</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">physical_range</span><span class="o">-&gt;</span><span class="n">NumberOfBytes</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u64</span> <span class="n">it</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">dst</span><span class="p">;</span> <span class="n">it</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">pml4e_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pml4e_idx</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">pml4e_idx</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">auto</span> <span class="n">self_ref</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml4e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="n">pml4e_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml4e_t</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">self_ref</span><span class="p">.</span><span class="n">pfn</span><span class="p">))</span> <span class="c1">// self-ref?</span>
          <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// ok - attempt translation</span>
        <span class="k">auto</span> <span class="n">pml4e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml4e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="n">mz_base</span><span class="p">.</span><span class="n">pml4_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml4e_t</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml4e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span> <span class="c1">// bad cr3, check next page...</span>

        <span class="k">auto</span> <span class="n">pml3e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml3e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml4e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">mz_base</span><span class="p">.</span><span class="n">pml3_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml3e_t</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml3e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">pml2e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml2e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml3e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">mz_base</span><span class="p">.</span><span class="n">pml2_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml2e_t</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml2e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">pml1e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml1e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml2e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">mz_base</span><span class="p">.</span><span class="n">pml1_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml1e_t</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml1e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="o">&lt;</span><span class="n">u16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml1e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">mz_base</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">!=</span> <span class="err">'</span><span class="n">ZM</span><span class="err">'</span><span class="p">)</span> <span class="c1">// check PE magic</span>
          <span class="k">break</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">_page_to_pfn</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="c1">// found cr3!</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">physical_range</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">physical_range</span><span class="o">-&gt;</span><span class="n">BaseAddress</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Thereâ€™s a lot more you can do in the way of filtering out bad pages before running expensive read operations, but I leave this as an exercise to the reader. In any case, this serves as a good proof of concept.</p>

<p><img src="/assets/image2.png" alt="Driver Output" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Some kernel mode anti-cheat solutions have now begun to obscure KPROCESS.DirectoryTableBase by effectively moving the address space via page table manipulation on startup. This prevents attaching to the real process space and makes it slightly more difficult for cheats and malware to to read/write the protected memory.]]></summary></entry><entry><title type="html">Inline x86 Syscall Abuse on x86_64 Systems</title><link href="http://localhost:4000/2025/04/20/Inline-x86-Syscall-Abuse-on-x86_64-Systems.html" rel="alternate" type="text/html" title="Inline x86 Syscall Abuse on x86_64 Systems" /><published>2025-04-20T05:12:41+02:00</published><updated>2025-04-20T05:12:41+02:00</updated><id>http://localhost:4000/2025/04/20/Inline-x86-Syscall-Abuse-on-x86_64-Systems</id><content type="html" xml:base="http://localhost:4000/2025/04/20/Inline-x86-Syscall-Abuse-on-x86_64-Systems.html"><![CDATA[<p>When we perform a <code class="language-plaintext highlighter-rouge">syscall</code>, we request that the OS do something. On Windows version <code class="language-plaintext highlighter-rouge">NT6+</code>, these system calls are implemented in <code class="language-plaintext highlighter-rouge">ntoskrnl</code> and <code class="language-plaintext highlighter-rouge">win32k</code> in exported tables <a href="https://hfiref0x.github.io/X86_64/NT6_syscalls.html"><code class="language-plaintext highlighter-rouge">KiServiceTables</code></a> and <a href="https://hfiref0x.github.io/X86_64/NT6_w32ksyscalls.html"><code class="language-plaintext highlighter-rouge">W32pServiceTables</code></a> respectively.</p>

<p>We can use syscalls to bridge the user-kernel gap not covered by public APIs, though many opaque routines are mirrored renames of syscalls, often with some error checking and so on. The majority of syscalls are trampolined via <code class="language-plaintext highlighter-rouge">ntdll</code>. We disassemble any x86 syscall.</p>

<p><img src="/assets/{07E01347-FB93-43D5-BB8E-3880096AEA4B}.png" alt="Syscall Disasm" /></p>

<p>The routine first places the syscall index into <code class="language-plaintext highlighter-rouge">EAX</code>. It then does something peculiar. Because the x86 call is not native, the syscall is instead routed through a translation layer <code class="language-plaintext highlighter-rouge">Wow64SystemServiceCall</code>. Instead of containing the expected <code class="language-plaintext highlighter-rouge">SYSENTER</code> instruction, it jumps into 64-bit mode and issues a <code class="language-plaintext highlighter-rouge">SYSCALL</code>.</p>

<p><img src="/assets/{1C4BCA20-5531-4364-B3D0-B45FF6EB2670}.png" alt="Wow64 Translation" /></p>

<p>We want to retrieve the address of this function, place the syscall id in <code class="language-plaintext highlighter-rouge">EAX</code>, dynamically fix the stack and return. Instead of calling the <code class="language-plaintext highlighter-rouge">ntdll</code> export, we avoid any hooks, filters and callbacks and instead ship the call straight to kernel. We can do this by allocating executable memory, setting up the function and calling it on the go.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">u64</span> <span class="nf">nt_wow64_transition</span><span class="p">(</span><span class="n">u8</span><span class="o">*</span> <span class="n">nt_base</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 1. vv vv vv vv</span>
  <span class="c1">// BA A0 A0 31 4B       mov     edx, 4B31A0A0h</span>
  <span class="c1">// FF D2                call    edx</span>

  <span class="c1">// 2.    vv vv vv vv</span>
  <span class="c1">// FF 25 24 22 3B 4B    jmp      ds:_Wow64Transition</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">uti</span><span class="o">::</span><span class="n">ida_sig</span><span class="o">&lt;</span><span class="n">u64</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">"BA ?? ?? ?? ?? FF D2 C2 34 00"</span><span class="p">).</span><span class="n">ref</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ref</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">arg_t</span><span class="p">&gt;</span>
<span class="n">u32</span> <span class="nf">nt_make_call</span><span class="p">(</span><span class="n">arg_t</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">u8</span> <span class="n">call_stub</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0xb8</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1">// mov eax, ?? ?? ?? ??</span>
    <span class="mh">0xba</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1">// mov edx, ?? ?? ?? ??</span>
    <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xd2</span><span class="p">,</span>                    <span class="c1">// call edx</span>
    <span class="mh">0xc2</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>               <span class="c1">// retn ?? ??</span>
  <span class="p">};</span>

  <span class="k">auto</span> <span class="n">mem_alloc</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">call_stub</span><span class="p">),</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_alloc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>

  <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">call_stub</span><span class="p">[</span><span class="mh">0x1</span><span class="p">])</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">call_stub</span><span class="p">[</span><span class="mh">0x6</span><span class="p">])</span> <span class="o">=</span> <span class="n">nt_wow64_transition</span><span class="p">(</span><span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">));</span> <span class="c1">// get wow64 translation</span>
  <span class="o">*</span><span class="p">(</span><span class="n">u16</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">call_stub</span><span class="p">[</span><span class="mh">0xd</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arg_t</span><span class="p">)</span> <span class="o">+</span> <span class="p">...);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">call_stub</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">mem_alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_stub</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// write stub to RWX alloc</span>

  <span class="k">auto</span> <span class="n">ret_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">(</span><span class="kr">__stdcall</span><span class="o">*</span><span class="p">)(</span><span class="n">arg_t</span><span class="p">...))(</span><span class="n">args</span><span class="p">...);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VirtualFree</span><span class="p">(</span><span class="n">mem_alloc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">call_stub</span><span class="p">),</span> <span class="n">MEM_RELEASE</span> <span class="o">|</span> <span class="n">MEM_DECOMMIT</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ret_status</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>With this method, we are able to call syscalls on the go without calling the <code class="language-plaintext highlighter-rouge">ntdll</code> trampoline methods. I leave further analysis of <code class="language-plaintext highlighter-rouge">Wow64Transition</code> as an exercise to the reader.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[When we perform a syscall, we request that the OS do something. On Windows version NT6+, these system calls are implemented in ntoskrnl and win32k in exported tables KiServiceTables and W32pServiceTables respectively.]]></summary></entry><entry><title type="html">Exploring CI.dll and Bigpool Cache</title><link href="http://localhost:4000/2025/04/18/Exploring-CI.dll-and-Bigpool-Cache.html" rel="alternate" type="text/html" title="Exploring CI.dll and Bigpool Cache" /><published>2025-04-18T03:12:41+02:00</published><updated>2025-04-18T03:12:41+02:00</updated><id>http://localhost:4000/2025/04/18/Exploring-CI.dll-and-Bigpool-Cache</id><content type="html" xml:base="http://localhost:4000/2025/04/18/Exploring-CI.dll-and-Bigpool-Cache.html"><![CDATA[<p>The <code class="language-plaintext highlighter-rouge">CI.dll</code> integrity module is responsible for authenticating and verifying the reliability of kernel modules. The kernel initializes it by calling <code class="language-plaintext highlighter-rouge">CiInitialize()</code>, which returns the <code class="language-plaintext highlighter-rouge">g_CiCallbacks</code> array. This list of callbacks is then used elsewhere in the kernel. For example, <code class="language-plaintext highlighter-rouge">CiValidateImageHeader()</code> is called when a driver is loaded to verify its signature.</p>

<p><img src="/assets/{FD14D6FB-2AEC-4018-9882-8ABCDAAA56CF}.png" alt="CiValidateImageHeader Call Stack" /></p>

<p>We navigate to <code class="language-plaintext highlighter-rouge">CiValidateImageHeader()</code> and follow the call into <code class="language-plaintext highlighter-rouge">CiInitializePhase2()</code>.</p>

<p><img src="/assets/{7E18B9B6-F4C0-4701-A08C-B2A6CF97B269}.png" alt="CiInitializePhase2 Call" /></p>

<p>Here, in <code class="language-plaintext highlighter-rouge">CiInitializePhase2()</code>, <code class="language-plaintext highlighter-rouge">CI.dll</code> creates the <code class="language-plaintext highlighter-rouge">g_CiEaCacheLookasideList</code> with a call to <code class="language-plaintext highlighter-rouge">ExInitializePagedLookasideList()</code> which has type <code class="language-plaintext highlighter-rouge">PAGED_LOOKASIDE_LIST</code>. See <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/24h2/_PAGED_LOOKASIDE_LIST">documentation.</a> This lookaside list tracks paged big pool (heap) allocations.</p>

<p>Insiders are already aware that there are two (well, three) pool allocators: regular and big allocator. The regular allocator is used for any allocation less than or equal to a page in size, including the 32 byte pool header and initial free block. Big pool allocator is used when the size is more than one page, or when the pool type is <code class="language-plaintext highlighter-rouge">CacheAligned</code>. Crucially, big pool allocations dont have room for headers, and are instead tracked in the <code class="language-plaintext highlighter-rouge">PoolBigTable</code>.</p>

<p><img src="/assets/image.png" alt="ExInitializePagedLookasideList Usage" /></p>

<p>In the docs, we see field <code class="language-plaintext highlighter-rouge">ListEntry</code> which we use to iterate over the list. Interestingly, we also see <code class="language-plaintext highlighter-rouge">PoolType</code>, <code class="language-plaintext highlighter-rouge">Tag</code> and <code class="language-plaintext highlighter-rouge">Size</code>. We generate the signature <code class="language-plaintext highlighter-rouge">48 8D 0D ?? ?? ?? ?? C7 44 24</code> and walk.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#pragma pack(push, 1)
</span><span class="k">struct</span> <span class="nc">ci_lookaside_t</span>
<span class="p">{</span>
  <span class="n">u8</span> <span class="n">pad0</span><span class="p">[</span><span class="mh">0x24</span><span class="p">];</span>
  <span class="n">u32</span> <span class="n">type</span><span class="p">;</span>                 <span class="c1">// +0x24</span>
  <span class="n">u32</span> <span class="n">tag</span><span class="p">;</span>                  <span class="c1">// +0x28</span>
  <span class="n">u32</span> <span class="n">size</span><span class="p">;</span>                 <span class="c1">// +0x2c</span>
  <span class="n">u8</span> <span class="n">pad1</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>
  <span class="n">list_entry_t</span> <span class="n">link</span><span class="p">;</span>        <span class="c1">// +0x40</span>
<span class="p">};</span>
<span class="cp">#pragma pack(pop)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">enum_ci_cache_lookaside</span><span class="p">(</span><span class="n">u8</span><span class="o">*</span> <span class="n">ci_base</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">ci_cache</span> <span class="o">=</span> <span class="n">uti</span><span class="o">::</span><span class="n">ida_sig</span><span class="o">&lt;</span><span class="n">ci_lookaside_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ci_base</span><span class="p">,</span> <span class="s">"48 8D 0D ?? ?? ?? ?? C7 44 24"</span><span class="p">).</span><span class="n">rva</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci_cache</span><span class="p">)</span> <span class="c1">// oopsie                                             	^^^^^^^^^^^</span>
    <span class="k">return</span><span class="p">;</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">ci_cache</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">f</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ci_cache</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">auto</span> <span class="n">it_entry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">ci_lookaside_t</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">it_entry</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">it_tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">it_entry</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
    <span class="n">DbgPrintEx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"-- size: %6X type: %4X tag: %c%c%c%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
      <span class="n">it_entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">it_entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">it_tag</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it_tag</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">it_tag</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">it_tag</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We load the driver and run it. The type is <code class="language-plaintext highlighter-rouge">POOL_TYPE</code>, which is <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type">documented.</a> The output shows many <code class="language-plaintext highlighter-rouge">PagedPool</code> entries with varying sizes. <code class="language-plaintext highlighter-rouge">CI.dll</code> keeps track of a lot of interesting telemetry. There are many lists like <code class="language-plaintext highlighter-rouge">g_BootDriverList</code>, <code class="language-plaintext highlighter-rouge">g_CiValidationLookasideList</code>, <code class="language-plaintext highlighter-rouge">g_KernelHashBucketList</code> and <code class="language-plaintext highlighter-rouge">g_KernelHashBucketList</code>.</p>

<p><img src="/assets/{83E0EFE6-C7EE-420A-92C1-590E6A2EE129}.png" alt="Output" /></p>

<p>The traditional way of dealing dealing with these lists is locking, deleting and creating them with <code class="language-plaintext highlighter-rouge">ExDeleteLookasideListEx()</code> and <code class="language-plaintext highlighter-rouge">ExInitializeLookasideListEx()</code>. But clearing lists which would otherwise include reference to legitimate drivers is suspicious. Indeed, the best approach is to walk every relevant list and unlinking references to your vulnerable driver.</p>

<p>In addition, <code class="language-plaintext highlighter-rouge">ntoskrnl</code> tracks additional telemetry like <code class="language-plaintext highlighter-rouge">PiDDBCacheTable</code>, <code class="language-plaintext highlighter-rouge">MmLastUnloadedDriver</code>, <code class="language-plaintext highlighter-rouge">MmUnloadedDrivers</code>. The more you dig, the more you uncover. All these lists, caches and trees are potential detection vectors. Advanced malware and cheats should consider all of them and more.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[The CI.dll integrity module is responsible for authenticating and verifying the reliability of kernel modules. The kernel initializes it by calling CiInitialize(), which returns the g_CiCallbacks array. This list of callbacks is then used elsewhere in the kernel. For example, CiValidateImageHeader() is called when a driver is loaded to verify its signature.]]></summary></entry><entry><title type="html">Minesweeper Classic ESP</title><link href="http://localhost:4000/2025/04/17/Minesweeper-Classic-ESP.html" rel="alternate" type="text/html" title="Minesweeper Classic ESP" /><published>2025-04-17T09:19:42+02:00</published><updated>2025-04-17T09:19:42+02:00</updated><id>http://localhost:4000/2025/04/17/Minesweeper-Classic-ESP</id><content type="html" xml:base="http://localhost:4000/2025/04/17/Minesweeper-Classic-ESP.html"><![CDATA[<p>Minesweeper is a fun little game about clicking squares and avoiding bombs. But Iâ€™ve always wondered how it works under the hood. A grid game. Thereâ€™s probably a bitmap somewhere.</p>

<p>In the context menu we can create a custom came by setting width, height and number of bombs. I attach a debugger and see where these are accessed. They bring me to the function responsible for showing the dialog <code class="language-plaintext highlighter-rouge">winmine.hlp</code>. We rename the variables.</p>

<p><img src="/assets/{AB29194B-780E-4E52-A8D0-86B679B54278}.png" alt="" /></p>

<p>By cross referencing where these are used we find multiple functions. Some store the custom game values to registry keys, others load defaults on startup. We also find an interesting function that loops, reducing the bomb count on each iteration.</p>

<p><img src="/assets/{FB211914-8E66-435F-9BAD-01036C06A600}.png" alt="" /></p>

<p>At this point it is quite clear what this function does. We loop over the bitmap, setting the bomb flag <code class="language-plaintext highlighter-rouge">0x80</code> at random using <code class="language-plaintext highlighter-rouge">rand</code>. We also see the bitmap stride <code class="language-plaintext highlighter-rouge">32 * Y + X</code>, with <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> starting at <code class="language-plaintext highlighter-rouge">1</code>. With this information, we are able to read the bitmap and check for bomb flags.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">loop_draw_esp</span><span class="p">(</span><span class="n">u8</span><span class="o">*</span> <span class="n">game</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">u32</span> <span class="n">hdc</span> <span class="o">=</span> <span class="n">GetDC</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// lazy, grab the entire screen</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdc</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="n">game</span> <span class="o">+</span> <span class="mh">0x5164</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// should clock start (is playing?)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">u32</span> <span class="n">win_x</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="n">game</span> <span class="o">+</span> <span class="mh">0x56B0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">18</span><span class="p">;</span>
  <span class="n">u32</span> <span class="n">win_y</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="n">game</span> <span class="o">+</span> <span class="mh">0x56B4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">105</span><span class="p">;</span> <span class="c1">// window pos + offset to tile grid</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="n">game</span> <span class="o">+</span> <span class="mh">0x5338</span><span class="p">);</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="n">game</span> <span class="o">+</span> <span class="mh">0x5334</span><span class="p">);</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="c1">// walk coords</span>
  <span class="p">{</span>
    <span class="n">u32</span> <span class="n">tile</span> <span class="o">=</span> <span class="p">(</span><span class="n">game</span> <span class="o">+</span> <span class="mh">0x5340</span><span class="p">)[</span><span class="mi">32</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tile</span> <span class="o">&amp;</span> <span class="mh">0x80u</span><span class="p">)</span> <span class="c1">// has bomb?</span>
      <span class="n">draw_tile</span><span class="p">(</span><span class="n">hdc</span><span class="p">,</span> <span class="n">win_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">15</span><span class="p">,</span> <span class="n">win_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">15</span><span class="p">,</span> <span class="n">RGB</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">ReleaseDC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hdc</span><span class="p">);</span>
  <span class="n">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>It really is that shrimple. We inject and play. This is the result.</p>

<p><img src="/assets/{EAB758A4-2E16-4FE7-929F-726D7CB065AB}.png" alt="" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Minesweeper is a fun little game about clicking squares and avoiding bombs. But Iâ€™ve always wondered how it works under the hood. A grid game. Thereâ€™s probably a bitmap somewhere.]]></summary></entry><entry><title type="html">PageView64 Dynamic IA32e Paging Structure Explorer</title><link href="http://localhost:4000/2025/04/17/PageView64.html" rel="alternate" type="text/html" title="PageView64 Dynamic IA32e Paging Structure Explorer" /><published>2025-04-17T07:19:42+02:00</published><updated>2025-04-17T07:19:42+02:00</updated><id>http://localhost:4000/2025/04/17/PageView64</id><content type="html" xml:base="http://localhost:4000/2025/04/17/PageView64.html"><![CDATA[<blockquote>
  <p>Paging is a system which allows each process to see a full virtual address space, without actually requiring the full amount of physical memory to be available or present. 32-bit x86 processors support 32-bit virtual addresses and 4-GiB virtual address spaces, and current 64-bit processors support 48-bit virtual addressing and 256-TiB virtual address spaces.</p>
  <ul>
    <li><a href="https://wiki.osdev.org/Paging#64-Bit_Paging">OSDev Wiki</a></li>
  </ul>
</blockquote>

<p><br /></p>
<h3 id="rationale"><strong>Rationale</strong></h3>
<p>For a long time I struggled to visualize <code class="language-plaintext highlighter-rouge">IA32e</code> paging structures in my head. I always viewed paging as redundant. Youâ€™d think paging redundant on modern systems. Indeed, it is possible to implement virtual addressing, protection and session spacing with identity mapping.</p>

<p>The argument for memory efficiency is also not very convincing, but there arenâ€™t many reasons for Microsoft to mess with things that already work well enough, not to mention that paging as a concept is more a vertical issue than just software alone.</p>

<p>From the malware perspective, acting on the underlying physical memory is far more powerful than using official <code class="language-plaintext highlighter-rouge">API</code> to adjust virtual memory. We are able to get around many of the restrictions placed on virtual memory. We can ignore session spacing and page protection. We can construct our own paging structures and allocate memory hidden from the <code class="language-plaintext highlighter-rouge">Virtual Address Descriptor</code> or <code class="language-plaintext highlighter-rouge">VAD</code>.</p>

<p>The following diagram describes the layout of an <code class="language-plaintext highlighter-rouge">IA32e</code> virtual address.</p>

<p><img src="/assets/4_level_paging.png" alt="IA32e Paging Overview" /></p>

<p>Each page table is a list of <code class="language-plaintext highlighter-rouge">512</code> addresses. The first <code class="language-plaintext highlighter-rouge">256</code> are reserved for user addresses. There are four page tables. Also consider that <code class="language-plaintext highlighter-rouge">512 * sizeof(uintptr_t) == PAGE_SIZE</code>. The base physical address of the <code class="language-plaintext highlighter-rouge">PML4</code> is described by <code class="language-plaintext highlighter-rouge">EPROCESS.DirectoryTableBase</code>.</p>

<p><br /></p>
<h3 id="address-translation"><strong>Address Translation</strong></h3>
<p>Paging relates to session spacing. When a thread goes from one address space to another via <code class="language-plaintext highlighter-rouge">SwapContext</code>, the <code class="language-plaintext highlighter-rouge">CR3</code> is set. When the <code class="language-plaintext highlighter-rouge">CPU</code> wants to translate a physical address, it first checks if the translation already exists in the <code class="language-plaintext highlighter-rouge">Translation Lookaside Buffer</code> or <code class="language-plaintext highlighter-rouge">TLB</code>. If no translation exists, it walks the page tables.</p>

<blockquote>
  <p>Paging in long mode is similar to that of 32-bit paging, except Physical Address Extension (PAE) is required. Registers CR2 and CR3 are extended to 64 bits. Instead of just having to utilize 3 levels of page maps: page directory pointer table, page directory, and page table, a fourth page-map table is used: the level-4 page map table (PML4). This allows a processor to map 48-bit virtual addresses to 52-bit physical addresses.</p>
  <ul>
    <li><a href="https://wiki.osdev.org/Paging#64-Bit_Paging">OSDev Wiki</a></li>
  </ul>
</blockquote>

<p>As a sidenote, you can flush the <code class="language-plaintext highlighter-rouge">TLB</code> by toggling the <code class="language-plaintext highlighter-rouge">CR4.PGE</code> bit or firing the <code class="language-plaintext highlighter-rouge">INVLPG</code> instruction. User mode applications can use <code class="language-plaintext highlighter-rouge">SwitchToThread()</code> to force a context switch.</p>

<p>A word on naming conventions. Four-level paging is implemented in both <code class="language-plaintext highlighter-rouge">IA32e</code> and <code class="language-plaintext highlighter-rouge">AMD64</code>, but with different naming schemes. This often leads to confusion. In this paper we simplify to <code class="language-plaintext highlighter-rouge">PML4</code>, <code class="language-plaintext highlighter-rouge">PML3</code>, <code class="language-plaintext highlighter-rouge">PML2</code> and <code class="language-plaintext highlighter-rouge">PML1</code>.</p>

<p>We translate by walking down the chain.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define _pfn_to_page(pfn) (pfn &lt;&lt; _page_shift)
</span>
<span class="n">u8</span><span class="o">*</span> <span class="nf">vtop</span><span class="p">(</span><span class="n">EPROCESS</span><span class="o">*</span> <span class="n">proc</span><span class="p">,</span> <span class="n">virt_addr_t</span> <span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// read from proc, but if it is currentproc we can obv __readcr3</span>
  <span class="c1">// procs can also obscure the DirectoryTableBase with tricks</span>
  <span class="n">pml4e_t</span> <span class="n">pml4e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml4e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">DirectoryTableBase</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">va</span><span class="p">.</span><span class="n">pml4_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml4e_t</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml4e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="n">pml3e_t</span> <span class="n">pml3e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml3e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml4e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">va</span><span class="p">.</span><span class="n">pml3_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml3e_t</span><span class="p">))</span><span class="o">&gt;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml3e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">pml2e_t</span> <span class="n">pml2e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml2e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml3e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">va</span><span class="p">.</span><span class="n">pml2_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml2e_t</span><span class="p">))</span><span class="o">&gt;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml2e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">pml1e_t</span> <span class="n">pml1e</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">pml1e_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml2e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">va</span><span class="p">.</span><span class="n">pml1_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pml1e_t</span><span class="p">))</span><span class="o">&gt;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pml1e</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="c1">// finally return pfn + page offset...</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)(</span><span class="n">_pfn_to_page</span><span class="p">(</span><span class="n">pml1e</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="o">+</span> <span class="n">va</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Both <code class="language-plaintext highlighter-rouge">PML3</code> and <code class="language-plaintext highlighter-rouge">PML2</code> can have large page entries, describing <code class="language-plaintext highlighter-rouge">1GB</code> and <code class="language-plaintext highlighter-rouge">2MB</code> pages respectively if <code class="language-plaintext highlighter-rouge">HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\LargePageDrivers</code> is set. This is all outlined in my <a href="https://gist.github.com/hLunaaa/f23a48775bbe5425b4825eefcebf1197">header file.</a> We call these <code class="language-plaintext highlighter-rouge">PML3e_LARGE</code> and <code class="language-plaintext highlighter-rouge">PML2e_LARGE</code>. So in page table <code class="language-plaintext highlighter-rouge">PML3</code>, entries can describe the <code class="language-plaintext highlighter-rouge">PML2</code> or a <code class="language-plaintext highlighter-rouge">1GB</code> page directly. Similarly, entries in <code class="language-plaintext highlighter-rouge">PML2</code> might describe the <code class="language-plaintext highlighter-rouge">PML1</code> or a <code class="language-plaintext highlighter-rouge">2MB</code> page directly. We can check for large page by checking the <code class="language-plaintext highlighter-rouge">PageSize</code> bit. I leave large page translation as an exercise to the reader.</p>

<p><br /></p>

<h3 id="demonstration"><strong>Demonstration</strong></h3>
<p><code class="language-plaintext highlighter-rouge">PageView64</code> was created to visualize these structures. The program consists of the <code class="language-plaintext highlighter-rouge">PageView64.sys</code> driver and <code class="language-plaintext highlighter-rouge">PageView64.exe</code> client. The driver calls <code class="language-plaintext highlighter-rouge">MmCopyMemory</code> on <code class="language-plaintext highlighter-rouge">IRP</code>. We send the process ID and receive the <code class="language-plaintext highlighter-rouge">4KB</code> page tables. The client uses <code class="language-plaintext highlighter-rouge">ImGui</code> with <code class="language-plaintext highlighter-rouge">SFML</code>.</p>

<video width="100%" controls="controls"><source src="/assets/PageView64.mp4" /></video>]]></content><author><name></name></author><summary type="html"><![CDATA[Paging is a system which allows each process to see a full virtual address space, without actually requiring the full amount of physical memory to be available or present. 32-bit x86 processors support 32-bit virtual addresses and 4-GiB virtual address spaces, and current 64-bit processors support 48-bit virtual addressing and 256-TiB virtual address spaces. OSDev Wiki]]></summary></entry></feed>