<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-04-17T09:49:09+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">hLunaaa</title><subtitle>C++ and 8086</subtitle><entry><title type="html">Minesweeper Classic ESP</title><link href="http://localhost:4000/2025/04/17/Minesweeper-Classic-ESP.html" rel="alternate" type="text/html" title="Minesweeper Classic ESP" /><published>2025-04-17T09:19:42+02:00</published><updated>2025-04-17T09:19:42+02:00</updated><id>http://localhost:4000/2025/04/17/Minesweeper-Classic-ESP</id><content type="html" xml:base="http://localhost:4000/2025/04/17/Minesweeper-Classic-ESP.html"><![CDATA[<p>Sex2</p>

<p><img src="/assets/4_level_paging.png" alt="IA32e Paging Overview" /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">u8</span><span class="o">*</span> <span class="nf">vtop</span><span class="p">(</span><span class="n">EPROCESS</span><span class="o">*</span> <span class="n">proc</span><span class="p">,</span> <span class="n">va_t</span> <span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// read from proc, but if it is currentproc we can obv __readcr3</span>
  <span class="c1">// procs can also obscure the DirectoryTableBase with tricks</span>
  <span class="n">pml4_t</span> <span class="n">pml4</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">DirectoryTableBase</span><span class="p">);</span>
  <span class="n">pml3_t</span> <span class="n">pml3</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml4</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml4_idx</span><span class="p">].</span><span class="n">pfn</span><span class="p">);</span>
  <span class="n">pml2_t</span> <span class="n">pml2</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml3</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml3_idx</span><span class="p">].</span><span class="n">pfn</span><span class="p">);</span>
  <span class="n">pml1_t</span> <span class="n">pml1</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml2</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml2_idx</span><span class="p">].</span><span class="n">pfn</span><span class="p">);</span>

  <span class="c1">// we also assume all pages are paged-in (present=1)...</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml1</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml1_idx</span><span class="p">].</span><span class="n">pfn</span> <span class="o">+</span> <span class="n">va</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Other image</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Sex2]]></summary></entry><entry><title type="html">PageView64 Dynamic IA32e Paging Structure Explorer</title><link href="http://localhost:4000/2025/04/17/PageView64.html" rel="alternate" type="text/html" title="PageView64 Dynamic IA32e Paging Structure Explorer" /><published>2025-04-17T07:19:42+02:00</published><updated>2025-04-17T07:19:42+02:00</updated><id>http://localhost:4000/2025/04/17/PageView64</id><content type="html" xml:base="http://localhost:4000/2025/04/17/PageView64.html"><![CDATA[<p>For a long time I struggled to visualize <code class="language-plaintext highlighter-rouge">IA32e</code> paging structures in my head. I always viewed paging as redundant. Indeed, four-level paging is largely irrelevant on modern systems. We can have virtual addressing without paging. We can have protection without paging. Heck, we can even have session spacing and virtualization based security.</p>

<p>The memory efficiency argument is an empty one, but there isn’t much reason for Microsoft and other <code class="language-plaintext highlighter-rouge">OS</code> vendors to redesign both <code class="language-plaintext highlighter-rouge">MMU</code> and <code class="language-plaintext highlighter-rouge">OS</code> for minimal gains. It’s not like they care about the sanity of programmers to begin with.</p>

<p>Interacting with the underlying, physical memory directly is far more powerful than only dealing with <code class="language-plaintext highlighter-rouge">VA</code>. We are able to ignore address spaces and page protection. Additionally, we can allocate our own memory by constructing four-level paging structures in the same way the <code class="language-plaintext highlighter-rouge">OS</code> does. Thus, we can hide our memory from the <code class="language-plaintext highlighter-rouge">Virtual Address Descriptor</code> or <code class="language-plaintext highlighter-rouge">VAD</code>.</p>

<p>The following diagram describes the layout of an <code class="language-plaintext highlighter-rouge">IA32e</code> virtual address.</p>

<p><img src="/assets/4_level_paging.png" alt="IA32e Paging Overview" /></p>

<p>Each page table is a list of <code class="language-plaintext highlighter-rouge">512</code> addresses. The first <code class="language-plaintext highlighter-rouge">256</code> are reserved for user addresses. IA32e currently supports four-level paging. This means there are four page tables. Four tables of <code class="language-plaintext highlighter-rouge">512</code> addresses. Also consider that <code class="language-plaintext highlighter-rouge">512 * sizeof(uintptr_t) == PAGE_SIZE</code>. In a perfect world where large pages do not exist, we could simply assume a page table entry exist for every index in the virtual address. The base physical address for the highest level page table, in our case <code class="language-plaintext highlighter-rouge">PML4</code>, is pointed to by <code class="language-plaintext highlighter-rouge">EPROCESS.DirectoryTableBase</code>. We can read the <code class="language-plaintext highlighter-rouge">0x1000</code> bytes to get the entire page table.</p>

<p>This is also how session spacing works. When an a scheduled thread is about to swap context into a different process address space, the <code class="language-plaintext highlighter-rouge">CR3</code> is set. When the <code class="language-plaintext highlighter-rouge">CPU</code> wants to translate a physical address, it first checks if the translation already exists in cache - the <code class="language-plaintext highlighter-rouge">Translation Lookaside Buffer</code> or <code class="language-plaintext highlighter-rouge">TLB</code>. If it doesn’t hit, it walks the tables just like us.</p>

<p>In my opinion, ‘sophisticated’ malware should never interact with virtual memory. To date, I have not seen any proper implementation of paging abuse in popular malware.</p>

<p>As a sidenote, you can flush the <code class="language-plaintext highlighter-rouge">TLB</code> by toggling the <code class="language-plaintext highlighter-rouge">CR4.PGE</code> bit or firing the <code class="language-plaintext highlighter-rouge">INVLPG</code> instruction.</p>

<p>A word on naming conventions. Four-level paging is implemented in both IA32e and AMD64, but with different naming scheme. This often causes confusion. I will simplify to <code class="language-plaintext highlighter-rouge">PML4</code>, <code class="language-plaintext highlighter-rouge">PML3</code>, <code class="language-plaintext highlighter-rouge">PML2</code> and <code class="language-plaintext highlighter-rouge">PML1</code>. Appending <code class="language-plaintext highlighter-rouge">e</code> refers to one of <code class="language-plaintext highlighter-rouge">512</code> entries in a page table.</p>

<p>Ignoring large pages, we could translate a virtual address with something like this.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">u8</span><span class="o">*</span> <span class="nf">vtop</span><span class="p">(</span><span class="n">EPROCESS</span><span class="o">*</span> <span class="n">proc</span><span class="p">,</span> <span class="n">va_t</span> <span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// read from proc, but if it is currentproc we can obv __readcr3</span>
  <span class="c1">// procs can also obscure the DirectoryTableBase with tricks</span>
  <span class="n">pml4_t</span> <span class="n">pml4</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">DirectoryTableBase</span><span class="p">);</span>
  <span class="n">pml3_t</span> <span class="n">pml3</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml4</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml4_idx</span><span class="p">].</span><span class="n">pfn</span><span class="p">);</span>
  <span class="n">pml2_t</span> <span class="n">pml2</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml3</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml3_idx</span><span class="p">].</span><span class="n">pfn</span><span class="p">);</span>
  <span class="n">pml1_t</span> <span class="n">pml1</span> <span class="o">=</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml2</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml2_idx</span><span class="p">].</span><span class="n">pfn</span><span class="p">);</span>

  <span class="c1">// we also assume all pages are paged-in (present=1)...</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">read</span><span class="o">&lt;</span><span class="n">ph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pml1</span><span class="p">[</span><span class="n">va</span><span class="p">.</span><span class="n">pml1_idx</span><span class="p">].</span><span class="n">pfn</span> <span class="o">+</span> <span class="n">va</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Intuitively you’d think to walk the page maps like what is shown above. However, both <code class="language-plaintext highlighter-rouge">PML3</code> and <code class="language-plaintext highlighter-rouge">PML2</code> have large page entries, describing <code class="language-plaintext highlighter-rouge">1GB</code> and <code class="language-plaintext highlighter-rouge">2MB</code> pages respectively. This is all outlined in my <a href="https://gist.github.com/hLunaaa/f23a48775bbe5425b4825eefcebf1197">header file.</a> We call these <code class="language-plaintext highlighter-rouge">PML3e_LARGE</code> and <code class="language-plaintext highlighter-rouge">PML2e_LARGE</code>. So in page table <code class="language-plaintext highlighter-rouge">PML3</code>, entries can describe the <code class="language-plaintext highlighter-rouge">PML2</code> or the large page directly. Similarly, entries in <code class="language-plaintext highlighter-rouge">PML2</code> might describe the <code class="language-plaintext highlighter-rouge">PML1</code> or a large page directly. We can check for large page by checking the <code class="language-plaintext highlighter-rouge">PageSize == 1</code> bit. Thus, we can do the above, but simply return as soon as we hit a large page. I leave this as an exercise to the reader.</p>

<p><code class="language-plaintext highlighter-rouge">PageView64</code> was created to visualize these structures. The program consists of the <code class="language-plaintext highlighter-rouge">PageView64.sys</code> driver and <code class="language-plaintext highlighter-rouge">PageView64.exe</code> client. The driver simply calls <code class="language-plaintext highlighter-rouge">MmCopyMemory</code> on <code class="language-plaintext highlighter-rouge">IRP</code>. We send the process ID and receive the <code class="language-plaintext highlighter-rouge">0x1000</code> long page tables. The client uses <code class="language-plaintext highlighter-rouge">SFML</code> with <code class="language-plaintext highlighter-rouge">ImGui</code>.</p>

<video width="740" controls="controls"><source src="/assets/PageView64.mp4" /></video>]]></content><author><name></name></author><summary type="html"><![CDATA[For a long time I struggled to visualize IA32e paging structures in my head. I always viewed paging as redundant. Indeed, four-level paging is largely irrelevant on modern systems. We can have virtual addressing without paging. We can have protection without paging. Heck, we can even have session spacing and virtualization based security.]]></summary></entry></feed>